
#ifndef HOBBES_LANG_TYPEPREDS_HASCTOR_HPP_INCLUDED
#define HOBBES_LANG_TYPEPREDS_HASCTOR_HPP_INCLUDED

#include <hobbes/lang/tyunqualify.H>

namespace hobbes {

struct HasCtor {
  MonoTypePtr variant;
  MonoTypePtr ctorlbl;
  MonoTypePtr ctorty;
};

// a "has-ctor eliminator" knows how to resolve a "HasCtor" constraint at a particular (category of) type
struct HCEliminator {
  virtual ~HCEliminator() = default;

  // is this HC instance eliminable?
  virtual bool satisfied(const TEnvPtr& tenv, const HasCtor&, Definitions*) const = 0;

  // is it possible for this HC instance to eventually be eliminated?
  virtual bool satisfiable(const TEnvPtr& tenv, const HasCtor&, Definitions*) const = 0;

  // refine the substitution set associated with this constraint
  virtual bool refine(const TEnvPtr& tenv, const HasCtor&, MonoTypeUnifier* s, Definitions*) = 0;

  // unqualify a constraint (satisfied() must have returned true)
  virtual ExprPtr unqualify(const TEnvPtr&, const ConstraintPtr&, const HasCtor&, const ExprPtr&, Definitions*) const = 0;

  // what would you call this eliminator?
  virtual std::string name() const = 0;
};

// a 'ctor verifier' is a scheme for validating types as generated by a named constructor somehow
class CtorVerifier : public Unqualifier {
public:
  CtorVerifier();
  static std::string constraintName();

  // extend the set of 'hasctor' eliminators dynamically (dangerous?)
  void addEliminator(const std::shared_ptr<HCEliminator>&);

  // unqualifier interface
  bool        refine(const TEnvPtr&,const ConstraintPtr&,MonoTypeUnifier*,Definitions*);
  bool        satisfied(const TEnvPtr&,const ConstraintPtr&,Definitions*)                  const;
  bool        satisfiable(const TEnvPtr&,const ConstraintPtr&,Definitions*)                const;
  void        explain(const TEnvPtr& tenv, const ConstraintPtr& cst, const ExprPtr& e, Definitions* ds, annmsgs* msgs);
  ExprPtr     unqualify(const TEnvPtr&,const ConstraintPtr&, const ExprPtr&, Definitions*) const;
  PolyTypePtr lookup   (const std::string& vn)                                             const;
  SymSet      bindings ()                                                                  const;
  FunDeps     dependencies(const ConstraintPtr&)                                           const;
private:
  using HCEliminators = std::vector<std::shared_ptr<HCEliminator>>;
  HCEliminators eliminators;
  HCEliminator* findEliminator(const TEnvPtr&, const HasCtor&, Definitions*) const;

  static bool dec(const ConstraintPtr&, HasCtor*);
};

}

#endif

