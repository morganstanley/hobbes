
// support reading and writing values through file descriptors
stdin :: int
stdin = 0

stdout :: int
stdout = 1

class BlockCodec a where
  readFrom :: int -> a
  writeTo  :: (int, a) -> ()

instance BlockCodec () where
  readFrom _ = ()
  writeTo fd _ = ()

instance BlockCodec bool where
  readFrom = fdReadBool
  writeTo  = fdWriteBool

instance BlockCodec byte where
  readFrom = fdReadByte
  writeTo  = fdWriteByte

instance BlockCodec char where
  readFrom = fdReadChar
  writeTo  = fdWriteChar

instance BlockCodec short where
  readFrom = fdReadShort
  writeTo  = fdWriteShort

instance BlockCodec int where
  readFrom = fdReadInt
  writeTo  = fdWriteInt

instance BlockCodec long where
  readFrom = fdReadLong
  writeTo  = fdWriteLong

instance BlockCodec int128 where
  readFrom = fdReadInt128
  writeTo  = fdWriteInt128

instance BlockCodec float where
  readFrom = fdReadFloat
  writeTo  = fdWriteFloat

instance BlockCodec double where
  readFrom = fdReadDouble
  writeTo  = fdWriteDouble

// times, datetimes, timespans, ...
instance (Convert t long) => BlockCodec t where
  readFrom fd   = convert(fdReadLong(fd))
  writeTo  fd t = fdWriteLong(fd, convert(t))

// arrays
readFromIntoArr :: (BlockCodec a) => (int, [a], long) -> ()
readFromIntoArr fd xs i =
  if (i == length(xs)) then
    ()
  else
    do{xs[i] <- readFrom(fd); readFromIntoArr(fd, xs, i+1);}

writeToArr :: (BlockCodec a) => (int, [a], long) -> ()
writeToArr fd xs i =
  if (i == length(xs)) then
    ()
  else
    (let _ = writeTo(fd, xs[i]) in writeToArr(fd, xs, i+1))

instance (BlockCodec a) => BlockCodec [a] where
  readFrom fd = let r = newArray(readFrom(fd) :: long); _ = readFromIntoArr(fd, r, 0L) in r
  writeTo fd xs = let _ = writeTo(fd, length(xs)) in writeToArr(fd, xs, 0L)

// static arrays
readFromIntoSA :: (BlockCodec a) => (int, [:a|n:], long, long) -> ()
readFromIntoSA fd xs i end =
  if (i == end) then
    ()
  else
    do{saelem(xs, i) <- readFrom(fd); readFromIntoSA(fd, xs, i+1, end);}

writeToSA :: (BlockCodec a) => (int, [:a|n:], long, long) -> ()
writeToSA fd xs i end =
  if (i == end) then
    ()
  else
    (let _ = writeTo(fd, saelem(xs, i)) in writeToSA(fd, xs, i+1, end))

instance (BlockCodec a) => BlockCodec [:a|n:] where
  readFrom fd = let r = newPrim(); _ = readFromIntoSA(fd, r, 0L, salength(r)) in r
  writeTo fd xs = writeToSA(fd, xs, 0L, salength(xs))

// tuples, records
class BlockDecInto a where
  readFromInto :: (int, a) -> ()

instance BlockDecInto () where
  readFromInto fd _ = ()

instance (p=(h*t), BlockDecInto h, BlockDecInto t) => BlockDecInto p where
  readFromInto fd p = do{readFromInto(fd, p.0); readFromInto(fd, tupleTail(p));}

instance (p=(h*t), BlockCodec h, BlockDecInto t) => BlockDecInto p where
  readFromInto fd p = do{p.0 <- (readFrom(fd) :: h); readFromInto(fd, tupleTail(p));}

instance (r={h*t}, BlockDecInto h, BlockDecInto t) => BlockDecInto r where
  readFromInto fd z = do{readFromInto(fd, recordHeadValue(z)); readFromInto(fd, recordTail(z));}

instance (r={h*t}, BlockCodec h, BlockDecInto t) => BlockDecInto r where
  readFromInto fd z = do{recordHeadValue(z) <- (readFrom(fd) :: h); readFromInto(fd, recordTail(z));}

instance (p=(h*t), BlockCodec h, BlockCodec t) => BlockCodec p where
  readFrom fd = do{r = (newPrim() :: p); readFromInto(fd, r); return r}
  writeTo fd p = do{writeTo(fd, p.0); writeTo(fd, tupleTail(p));}

instance (r={h*t}, BlockCodec h, BlockCodec t) => BlockCodec r where
  readFrom fd = do{z = (newPrim() :: r); readFromInto(fd, z); return z}
  writeTo fd z = do{writeTo(fd, recordHeadValue(z)); writeTo(fd, recordTail(z));}

// enum-like variants
class CanEnumBlockCodec v
instance (v=|()+0|) => CanEnumBlockCodec v
instance (v=|()+t|, CanEnumBlockCodec t) => CanEnumBlockCodec v

instance (CanEnumBlockCodec v) => BlockCodec v where
  readFrom fd   = unsafeCast({t=fdReadInt(fd)})
  writeTo  fd x = fdWriteInt(fd, (unsafeCast(x)::{t:int}).t)

// variants
class BlockReadVar v where
  readVarByTag :: (int, int) -> v

instance (v=|h+0|, BlockCodec h) => BlockReadVar v where
  readVarByTag fd _ = variantInjectHead(readFrom(fd) :: h)

instance (v=|h+t|, BlockCodec h, BlockReadVar t) => BlockReadVar v where
  readVarByTag fd tg = if (tg == 0) then variantInjectHead(readFrom(fd) :: h) else variantLiftTail(readVarByTag(fd, tg - 1) :: t)

class BlockWriteVar v where
  writeVarWithTag :: (int, int, v) -> ()

instance (v=|h+0|, BlockCodec h) => BlockWriteVar v where
  writeVarWithTag fd tg v = variantSplit(v, \h.let _ = writeTo(fd, tg) in writeTo(fd, h), toClosure(\t.()))

instance (v=|h+t|, BlockCodec h, BlockWriteVar t) => BlockWriteVar v where
  writeVarWithTag fd tg v = variantSplit(v, \h.let _ = writeTo(fd, tg) in writeTo(fd, h), \t.writeVarWithTag(fd, tg+1, t))

instance (BlockReadVar v, BlockWriteVar v) => BlockCodec v where
  readFrom fd = readVarByTag(fd, readFrom(fd))
  writeTo fd v = writeVarWithTag(fd, 0, v)

// opaque types whose representations can be encoded
instance (Data t r, BlockCodec r) => BlockCodec t where
  readFrom fd = unsafeCast(readFrom(fd)::r)
  writeTo fd x = writeTo(fd, unsafeCast(x)::r)

